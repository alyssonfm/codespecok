using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Structures
{
    public static class CategoryType
    {
		public const String PRECONDITION = "precondition";
        public const String POSTCONDITION = "postcondition";
        public const String INVARIANT = "invariant";
        public const String CONSTRAINT = "constraint";
        public const String EVALUATION = "evaluation";
        public const String MEANINGLESS = "meaningless";
        public const String NEUTRAL = "";
	}

    /// <summary>
    /// Class used to detail nonconformances between code and contracts founded on
    /// C# projects written with CodeContracts clauses.
    /// </summary>
    public class Nonconformance
    {
        private String _type;

        // For nonconformance filtering.
        private bool _meaningless = false;
        
        // For results.xml presentation.
        private String _testFileName = "";
        private String _numberedTest = "";
        private String _errorMessage = "";
        private String _className = "";
        private String _methodName = "";
        private String _namespaceName = "";
        // Categorization module main product.
        private String _cause = "";
        // StackTrace related.
        private String [] _stackTraceOrder;
        private int _stackTraceLenght;

        /// <summary>
        /// Creates Nonconformances using data via VsTest.Console.exe output.
        /// </summary>
        /// <param name="message">The message of error founded.</param>
        /// <param name="stackTrace">The stackTrace generated by nonconformances.</param>
        public Nonconformance(String message, String stackTrace)
        {
            this.SetStackTrace(stackTrace);
            this.SetType();
            if (!IsMeaningless())
            {
                this.SetTestInformations();
                this.SetErrorMessage(message);
                this.SetLocation();
            }
        }

        public void SetLocation()
        {
            // Take line that will tell location of Nonconformance.
            String data;
            if (this._type == CategoryType.INVARIANT)
            {
                data = this._stackTraceOrder[4];
            }
            else
            {
                data = this._stackTraceOrder[3];
            }

            int first, last;
            first = data.IndexOf(" ", 3) + 1;
            last = data.IndexOf(".");
            this._namespaceName = data.Substring(first, last - first);
            first = last + 1;
            last = data.IndexOf(".", first);
            this._className = data.Substring(first, last - first);
            first = last + 1;
            last = data.IndexOf("(", first);
            this._methodName = data.Substring(first, last - first);
        }

        /// <summary>
        /// Set the Error Message thrown when nonconformance were found.
        /// </summary>
        /// <param name="message">Error message thrown when nonconformance were found.</param>
        public void SetErrorMessage(String message)
        {
            this._errorMessage = message;
        }

        /// <summary>
        /// Set test informations about which TestFile and which TestUnit found nonconformance.
        /// </summary>
        public void SetTestInformations()
        {
            String test = "RandoopTest";
            String unit = "UnitTest";
            String data = this._stackTraceOrder[this._stackTraceLenght - 2];
            String number = data.Substring(data.LastIndexOf(test) + test.Length, data.LastIndexOf("." + unit));
            this._testFileName = test + number;
            this._numberedTest = unit + number;
        }

        /// <summary>
        /// Set the type of Nonconformance
        /// </summary>
        public void SetType()
        {
            String data = this._stackTraceOrder[2];
            if (data.Contains("Invariant"))
            {
                this._type = CategoryType.INVARIANT;
            } else if(data.Contains("Ensures")){
                this._type = CategoryType.POSTCONDITION;
            }
            else if (data.Contains("Requires"))
            {
                if (this._stackTraceLenght == 5)
                {
                    this.SetMeaningless(true);
                    this._type = CategoryType.MEANINGLESS;
                }
                else
                {
                    this._type = CategoryType.PRECONDITION;
                }
            }
        }

        /// <summary>
        /// Set a new value for isMeaningless expression.
        /// </summary>
        /// <param name="value">The new value for isMeaningless.</param> 
        public void SetMeaningless(bool value)
        {
            this._meaningless = value;
        }

        /// <summary>
        /// Defines if the nonconformance is meaningless or not.
        /// </summary>
        /// <returns>Whether nonconformance is meaningless or not.</returns>
        public bool IsMeaningless()
        {
            return this._meaningless;
        }

        /// <summary>
        /// Save StackTrace of nonconformance on the object on a array.
        /// </summary>
        /// <param name="stackTrace">The string containing all StackTrace.</param>
        public void SetStackTrace(string stackTrace)
        {
            this._stackTraceOrder = stackTrace.Split(new Char[] { '\n' });
            this._stackTraceLenght = this._stackTraceOrder.Length;
        }
    }
}
